# E18

## Tester/debugger notre API

### Rest Client

```text
Nom¬†: REST Client
ID¬†: humao.rest-client
Description¬†: REST Client for Visual Studio Code
Version¬†: 0.25.1
Serveur de publication¬†: Huachao Mao
Lien de la Place de march√© pour VS¬†: https://marketplace.visualstudio.com/items?itemName=humao.rest-client
```

on liste nos requ√™te dans un fichier `fichier.http`

En surlignant une requete, on peux √©xecuter celle ci sp√©cifiquement.

### Thunder Client

```text
Nom¬†: Thunder Client
ID¬†: rangav.vscode-thunder-client
Description¬†: Lightweight Rest API Client for VS Code
Version¬†: 2.0.0
Serveur de publication¬†: Ranga Vadhineni
Lien de la Place de march√© pour VS¬†: https://marketplace.visualstudio.com/items?itemName=rangav.vscode-thunder-client
```

## POST et deserialize

Quand on est en mode "API", si on permet la cr√©ation avec la route `POST`, on doit s'attendre √† recevoir du JSON.

Simple en PHP, on `deserialize` le json que l'on re√ßoit et üí• on a un objet PHP.

On injecte la requ√®te HTTP dans notre fonction pour en r√©cup√©rer le contenu

```php
use Symfony\Component\HttpFoundation\Request;
public function createItem(Request $request)
{
    // R√©cup√©rer le contenu JSON
    $jsonContent = $request->getContent();
```

Comme pr√©vu on `deserialize`, c'est √† dire que l'on transforme le JSON en Objet en pr√©cisant l'entit√© que l'on veux.

On n'oublie pas d'injecter le Serializer de Symfony

```php
use Symfony\Component\Serializer\SerializerInterface;
public function createItem(Request $request, SerializerInterface $serializer)
{
    // R√©cup√©rer le contenu JSON
    $jsonContent = $request->getContent();
    // D√©s√©rialiser (convertir) le JSON en entit√© Doctrine Genre
    $genre = $serializer->deserialize($jsonContent, Genre::class, 'json');
```

üéâ trop facile, on donnes √ßa √† Doctrine pour qu'il le mettes en BDD et c'est bon üí™

```php
use Doctrine\ORM\EntityManagerInterface;
public function createItem(Request $request, SerializerInterface $serializer, EntityManagerInterface $doctrine)
{
    // R√©cup√©rer le contenu JSON
    $jsonContent = $request->getContent();
    // D√©s√©rialiser (convertir) le JSON en entit√© Doctrine Genre
    $genre = $serializer->deserialize($jsonContent, Genre::class, 'json');
    // On sauvegarde l'entit√©
    $doctrine->persist($genre);
    $doctrine->flush();
```

üòÖ `SQLSTATE[xxxx] xxxx cannot be null`

Comment √ßa MySQL n'est pas content ? üëø

Ben oui, il manque des donn√©es, on va demander √† Symfony de nous valider tout √ßa üí™ et surtout de nous dire ce qui coince.
Comme √ßa on pr√©vient notre utilisateur en front et on lui d√©crit les probl√®mes pour qu'il s'adapte et qu'il nous envoie les bonnes donn√©es.

```php
use Symfony\Component\Validator\Validator\ValidatorInterface;
public function createItem(Request $request, SerializerInterface $serializer, EntityManagerInterface $doctrine, ValidatorInterface $validator)
{
    // R√©cup√©rer le contenu JSON
    $jsonContent = $request->getContent();
    // D√©s√©rialiser (convertir) le JSON en entit√© Doctrine Genre
    $Genre = $serializer->deserialize($jsonContent, Genre::class, 'json');
    // Valider l'entit√©
    // @link : https://symfony.com/doc/current/validation.html#using-the-validator-service
    $errors = $validator->validate($Genre);
    // Y'a-t-il des erreurs ?
    if (count($errors) > 0) {
        // @todo Retourner des erreurs de validation propres
        return $this->json($errors, Response::HTTP_UNPROCESSABLE_ENTITY);
    }
    // On sauvegarde l'entit√©
    $doctrine->persist($Genre);
    $doctrine->flush();

    // on renvoit un code 201 et l'objet cr√©e
    return $this->json($Genre, Response::HTTP_CREATED);
```

üéâ Tout fonctionne √† merveille, on valide que tout est bon

üí• notre utilisateur nous envoit une chaine de caract√®res qui n'est pas du JSON.

le serializer n'arrive donc pas √† deserializer, normal on lui donne un truc tout cass√©.

On doit donc attraper cette erreur, pour cela on utilise le `try{} catch(){}`

```php
try // essaye de faire d'√©x√©cuter ce code
{
    /** @var Genre $Genre */
    $Genre = $serializerInterface->deserialize($jsonContent, Genre::class, 'json');
}
catch(Exception $e) // si tu n'y arrives pas
{
    // j'arrive ici si une exception a √©t√© lanc√©e
    // dans notre cas si le json fourni n'est pas bien √©crit : en fait c'est pas du json
    return $this->json("Le JSON est mal form√©", Response::HTTP_BAD_REQUEST);
}
```

Quand on a fini la cr√©ation on propose une page de redirection notre utilisateur sur la bonne route.
Pour cela on utilise l'ent√™te HTTP : `Location`

```php
return $this->json(
        $Genre,
        // je pr√©cise que tout est OK de mon cot√© en pr√©cisant que la cr√©ation c'est bien pass√©
        // 201
        Response::HTTP_CREATED,
        // REST demande un header Location + URL de la ressource
        [
            // Nom de l'en-t√™te + URL
            'Location' => $this->generateUrl('api_genres_read', ['id' => $Genre->getId()])
        ],
        // c'est ici que je fournis les groupes de serialisation
        [
            "groups" => 
            [
                "genre_read"
            ]
        ]
    );
```

### PUT, PATCH : update

1. route avec les m√©thodes PUT / PATCH
2. la route doit √™tre form√© : `/api/<ressources>/{id<\d+>}`
3. find / paramConverter
   1. si l'objet n'existe pas ...
4. d√©serialiser
5. mettre √† jour l'objet
6. flush

[doc](https://symfony.com/doc/current/components/serializer.html#deserializing-in-an-existing-object)

```php
$serializerInterface->deserialize(
    $jsonContent,
    Genre::class,
    'json',
    //? avec le param√®tre context, on pr√©cise l'objet √† mettre √† jour 
    [AbstractNormalizer::OBJECT_TO_POPULATE => $genre]
);
```

## s√©curiser notre API

l'objectif est de faire une route pour authentifier notre utilisateur, et en √©change on lui donnera un JWT (JSON Web Token)

Pour toutes les routes s√©curis√©es, on va demander ce token pour s'assurer que l'utilisateur est bien authentifi√©, et aussi que ses droits/roles sont valables.

[LexikJWTAuthenticationBundle](https://github.com/lexik/LexikJWTAuthenticationBundle)

[Installation](https://github.com/lexik/LexikJWTAuthenticationBundle/blob/2.x/Resources/doc/index.rst#installation)

```bash
composer require lexik/jwt-authentication-bundle
```

‚ö†Ô∏è Que pour la premi√®re installation :

```bash
bin/console lexik:jwt:generate-keypair
```

cela cr√©e 2 fichiers dans `config\jwt` :

* private.pem
* public.pem

sans ces fichiers rien ne fonctionne.

on modifie le fichier `config/packages/lexik_jwt_authentication.yaml`

```yaml
    # 64800 = 18h
    token_ttl: 64800
```

√† ajouter dans le fichier de `security.yaml`

```yaml
    firewalls:
        # la partie login de Lexik
        login:
            pattern: ^/api/login
            stateless: true
            json_login:
                check_path: /api/login_check
                success_handler: lexik_jwt_authentication.handler.authentication_success
                failure_handler: lexik_jwt_authentication.handler.authentication_failure
        
        # zone d'intervention du JWT
        api:
            pattern:   ^/api
            stateless: true
            jwt: ~
        
        
        access_control:
            # on ouvre la route de login
            - { path: ^/api/login, roles: PUBLIC_ACCESS }
            # on ferme toutes les routes /api
            # √† vous de bien d√©finir cette partie
            - { path: ^/api,       roles: IS_AUTHENTICATED_FULLY }
```

derni√®re chose : ajouter la route pour s'authentifier `config/routes.yaml`

```yaml
api_login_check:
    path: /api/login_check
```

### obtenir notre token

dans la doc on a que curl comme exemple

```bash
curl -X POST -H "Content-Type: application/json" http://localhost:8080/api/login_check -d '{"username":"johndoe","password":"test"}'
```

traduction de la commande Curl :

`POST http://localhost:8080/api/login_check`

avec ce contenu, faire ATTENTION aux noms des propri√©t√©s, elles sont obligatoire

```json
{
    "username":"johndoe",
    "password":"test"
}
```

si √ßa marche on re√ßoit un token

```json
{
  "token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJpYXQiOjE2NjkwMzYzNDAsImV4cCI6MTY2OTEwMTE0MCwicm9sZXMiOlsiUk9MRV9BRE1JTiIsIlJPTEVfTUFOQUdFUiIsIlJPTEVfVVNFUiJdLCJ1c2VybmFtZSI6ImpiQG9jbG9jay5pbyJ9.lVJpZlDaE9kZuE1hfgcPnSE6Z-X1kaCpDQSAgyIiVNY-_Xz5Fv4Sr-KKVHqVU8SBfMEtzfA3GmYwOudGzkyfVo0OZEi6EUlMK8LiUDGnQsNH0h5lpXwJLC_vLLasnyAxBihr7-XilEW-RJSj6Kz5Q-vJbXY-y9jB-Qu3I27fBM-g-Ct6lhEvkEazgF1AeAUI9sNFOqc7G5yWhGqI60daQql7ozDP796vM91bYlvyBC8QN2hsRnk4-hmAlmZbklonzbY6seLQwh00uEjNDYJtyw2D6UlE8pzBWOIR4XWmiA9TubnXKS6kNNepl3P0LDPvf9y4xhpDKGAZdDi8f087EA"
}
```

si √ßa ne se passe pas bien, lire le message d'erreur

### comment on pr√©sente notre bracelet (Hellfest)

si je ne fournit pas le token :

```json
{
  "code": 401,
  "message": "JWT Token not found"
}
```

#### thunderclient

pour fournir le token, dans la partie `Auth`, se mettre en `Bearer` et donner le token.

#### restClient

```text
// pour √™tre authentifier sur une route
GET http://localhost:8080/api/genres
Authorization: Bearer token_sans_quote
```

### la gestion des droits cot√© symfo

pour les droits, on fait comme avant :

* ACL, dans le security.yaml
* pas d'annotation `@isGranted` car cela fait un HTML
  * utiliser `$this->isGranted()` dans nos controlleurs
* ne pas faire de `$this->denyAccessUnlessGranted()` car cela fait un HTML

### securis√© ? pas ce qui se fait de mieux

pour visualiser le contenu d'un token : [jwt.io](https://jwt.io/#debugger-io)

mais cela ne veux pas dire que c'est trou√©, c'est juste que l'on peu lire le contenu, pas g√©n√©rer le token

## CORS

[github](https://github.com/nelmio/NelmioCorsBundle)

```bash
composer require nelmio/cors-bundle
```

## API factice

j'ai mes entit√©s, mais pas encore de donn√©es.
le front a besoin de donn√©es pour tester son affichage.

sans √ßa ils ne peuvent pas bosser.

On va donc mettre en place une API factice
Cr√©ons un controller `ApiFactice`